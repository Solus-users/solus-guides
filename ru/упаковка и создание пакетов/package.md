# Package.yml
Все пакеты создаются из одного файла сборки, который предоставляет все необходимые метаданные для диспетчера пакетов, а также шаги по упаковке, необходимые для создания пакета. Это соответствует спецификации YAML.

## Формат
Все файлы package.yml должны быть действительными YAML.

Файл организован в виде иерархии ключ → значение. Инструмент ypkg анализирует файл package.yml для создания соответствующего пакета декларативным образом, поэтому большинство ключей представляют собой простые строки, списки или вложенные пары ключ → значение. Особый случай - этапы упаковки, которые представляют собой скрипты.

Ниже приведен пример файла:

```yml
name       : nano
version    : 2.9.5
release    : 96
source     :
    - https://www.nano-editor.org/dist/v2.9/nano-2.9.5.tar.xz : 7b8d181cb57f42fa86a380bb9ad46abab859b60383607f731b65a9077f4b4e19
license    : GPL-3.0-or-later
summary    : Small, friendly text editor inspired by Pico
component  : system.devel
description: |
        GNU nano is an easy-to-use text editor originally designed as a replacement for Pico, the ncurses-based editor from the non-free mailer package Pine (itself now available under the Apache License as Alpine).
setup      : |
    %patch -p1 < $pkgfiles/0001-Use-a-stateless-configuration.patch
    %reconfigure --enable-utf8 --docdir=/usr/share/doc/nano    
build      : |
        %make
install    : |
    %make_install
    install -D -m 00644 $pkgfiles/nanorc $installdir/usr/share/defaults/nano/nanorc
    install -D -m 00644 $pkgfiles/git.nanorc $installdir/usr/share/nano/git.nanorc
    # https://github.com/scopatz/nanorc
    for rcFile in $pkgfiles/nanorc-extras/*.nanorc; do
        install -m 00644 $rcFile $installdir/usr/share/nano
    done
```
## Ключи
Не все поля в package.yml являются обязательными, но есть небольшой выбор. Ниже представлен полный список доступных полей.
    
### Обязательные ключи

| Название ключа | Тип | Описание |
----|----|----
**name** | `string` | Имя пакета. Это также используется в качестве основы для всех имен вложенных пакетов. Если это не неизбежно, оно должно совпадать с именем восходящего потока |
**version** | `string` | Версия текущего упакованного программного обеспечения. В большинстве случаев он взят из архива |
**release** | `integer` | Задает номер текущего выпуска. Обновления в номере пакета основаны на этом номере выпуска, а не на номере версии. Таким образом, чтобы выпускать обновление для пользователей, это число должно быть увеличено на единицу.
**license** | `string(s)`	  | Действующая лицензия (-и) на апстрим. Постарайтесь убедиться, что они используют идентификаторы SPDX |
**source** | `dict(s)` | URL-адрес источника восходящего потока (т. Е. Tarball) с допустимым значением sha256sum. В качестве альтернативы URL-адрес репозитория git с префиксом git 
**component** | `string	` | Компонент / группа пакетов, к которой принадлежит этот пакет. Проверьте доступные компоненты через ```eopkg lc``` 
**summary** | `сstring`| Краткое описание пакета или отображаемое имя. 
**description** | `string` | Более подробное описание программного обеспечения, обычно берется с веб-сайта производителя. 

## Дополнительные, необязательные ключи

| Название ключа | Тип | Описание |
----|----|----
**clang** | `bool` | Установите значение `yes`, если этот пакет будет построен с помощью Clang. 
**extract** | `bool` | Установите значение «no», чтобы отключить автоматическое извлечение источника.
**autodep** | `bool` | Установите значение `no`, чтобы отключить автоматическое разрешение двоичных зависимостей во время сборки.
**emul32** | `bool` | Установите значение `yes`, чтобы включить сборку `-m32` (32-битные библиотеки).
**libsplit** | `bool` | Установите значение `no`, чтобы запретить разбиение библиотек на подпакеты `devel`.
**conflicts** | `string(s)` | Укажите пакеты, которые нельзя установить вместе с этим.
**optimize** | `list` | Укажите предустановленные ключи для изменения флагов компилятора и компоновщика во время сборки. Вы можете узнать больше здесь
**builddeps** | `list` | Укажите зависимости сборки для пакета. Вы можете узнать больше здесь.
**rundeps** | `dict(s)` | Укажите дополнительные зависимости времени выполнения для пакетов. Вы можете узнать больше здесь 
**replaces** | `dict(s)` | Замените один пакет другим, который используется при переименовании или прекращении поддержки пакетов для чистых путей обновления.
**patterns** | `dict(s)` | Позволяет детально контролировать размещение файлов в пакете или подпакетах. Полезно для пакетов, которые не имеют стабильного релиза (например, для файлов `/usr/bin`)
**environment** | `unicode` | Укажите код, который будет экспортирован на все этапы упаковки сборки (т.е. экспорт переменных для всей сборки).
**networking** | `bool` | Установите значение `yes`, чтобы разрешить работу в сети в solbuild.
**homepage** | `string` | Предоставляет ссылку на домашнюю страницу пакета в Центре программного обеспечения

### Ключи шагов упаковки, необязательные ключи

Все шаги упаковки считаются необязательными, однако отсутствие шага `install` не приведет к созданию пакета. Каждый из этих ключей содержит контент, который будет помещен в сценарий и выполнен в контролируемой среде для выполнения сборки пакета. По сути, это сценарии Bash с предопределенной средой. 

Название шага | Описание
---- | ----
**setup** | Выполняется после извлечения исходников. Это правильное место для выполнения любой процедуры `configure` или` patch` к исходнику. 
**build** | Используйте этот шаг для запуска части сборки, то есть `make` 
**install** | Здесь вы должны установить файлы в каталог окончательной упаковки, то есть `make install` 
**check** | Здесь должны выполняться тесты / проверка, т.е. `make check` 
**profile** | Здесь должны быть указаны тесты профилирования. `ypkg` будет обрабатывать флаги установки для генерации данных профилирования и использования этих данных для оптимизированной сборки.


## Значения для оптимизации
Одно или несколько значений оптимизации могут быть указаны в списке с помощью ключа оптимизации в файле `package.yml`. Некоторые значения могут переопределять или конфликтовать друг с другом, и их следует использовать только там, где они обеспечивают повышение производительности или исправляют ошибку в пакете или сборке.

Значения для оптимизации| Описание
---- | ----
**speed** | Оптимизируйте пакет для производительности `-O3` плюс другие флаги.
**size** | Оптимизируйте сборку пакета, чтобы минимизировать размер `-Os`. Не поддерживается с лязгом.
**no-bind-now** | Настраивает пакет, чтобы отключить определенные флаги, где RELRO не поддерживается.
**no-symbolic** | Отключает флаг компоновщика -Wl, -Bsymbolic-functions.
**unroll-loops** |Включает `-funroll-loops`. Используйте это умеренно, только если это дает доказанную пользу.
**runpath** | Включает `-Wl, - enable-new-dtags`, чтобы компоновщик использовал RUNPATH вместо RPATH.
**avx256** | Отключает `-mprefer-vector-width = 128` в сборках avx2.
**thin-lto** | Включает Thin Link Time Optimization `-flto=thin` с поддерживаемым компоновщиком. 
**lto** | Включает Link Time Optimization `-flto`.

## Макросы

Для дополнительной помощи при упаковке доступен ряд макросов. Это просто сокращенные способы выполнения обычной операции сборки. Они также гарантируют согласованность итогового пакета. Эти макросы доступны только на наших этапах упаковки, поскольку они заменяются в сценарии перед выполнением.

### Использование

Макросы имеют префикс `%` и заменяются перед выполнением вашего скрипта. Макросы, заканчивающиеся на `%`, используются для предоставления скрипту имен каталогов или значений сборки.

``` bash
# Запуск макроса конфигурации с заданными аргументами
%configure --disable-static
```

### Действующие макросы

Макросы | Описание
---- | ----
**%autogen** | Запускает автогенерацию с нашим `%CONFOPTS%` для создания скрипта настройки, затем переходит к запуску `%configure`.
**%cmake** | Настройте проект cmake с параметрами, специфичными для дистрибутива, такими как префикс и тип выпуска.
**%cmake_ninja** | Настройте проект cmake с помощью ninja, чтобы его можно было использовать с макросами `%ninja_build`,`%ninja_install` и `%ninja_check`.
**%configure** | Запускает `. / Configure` с нашим макросом переменной`%CONFOPTS%`.
**%make** | Запускает команду `make` со счетчиком заданий, указанным в `eopkg.conf`
**%make_install** | Выполняет `make install`, используя вариант` DESTDIR`. Должен работать для подавляющего большинства пакетов.
**%patch** | Разумный макрос исправления для запуска в пакетном режиме и не загрязняет дерево исходных текстов в случае сбоя
**%apply_patches** | Применяет все патчи, перечисленные в файле `series` в папке`./Files`.
**%reconfigure** | Обновляет сценарии сборки, такие как `./Configure`, и переходит к запуску`%configure`.

### Действующие макросы Haskell

Макросы | Описание
---- | ----
**%cabal_configure** | Запускает cabal configure с префиксом, libdir и т.д. Обеспечивает копирование необходимого package.conf.d в правильное место.
**%cabal_build** | Запускает сборку кабалы с помощью `%JOBS%`
**%cabal_install** | Запускает копию Кабала в `$installdir`
**%cabal_register** | Запускает регистр cabal для создания pkg-config для пакета и версии, затем устанавливает файл conf.

### Действующие макросы Ninja

Макросы | Описание
---- | ----
**%meson_configure** | Запускает meson с нашими CFLAGS и соответствующими флагами, такими как libdir.
**%ninja_build** | Запускает ninja и передает нашу переменную %JOBS%. Этот макрос устарел *%meson_build*.
**%ninja_install** | Запускает установку meson и передает соответствующие переменные DESTDIR и %JOBS%. Этот макрос устарел *%meson_install*.
**%ninja_check** | Запускает тест ninja и передает нашу переменную %JOBS%. Этот макрос устарел *%meson_check*.

### Действующие макросы Perl

Макросы | Описание
---- | ----
**%perl_setup** | Запускает сценарии установки Perl Build.pl или Makefile.pl с соответствующими флагами переменных.
**%perl_build** | Запускает сценарии сборки Perl или пытается `%make`.
**%perl_install** | Запускает сценарии установки Perl или пытается выполнить `% make_install`.

### Действующие макросы Python

Макросы | Описание
---- | ----
**%python_setup** | Запускает часть сборки setup.py с использованием python2.
**%python_install** | Запускает установочную часть setup.py в соответствующий корень с помощью python2.
**%python_test** |Без аргументов запускает тестовую часть setup.py. Используя сценарий `.py`, выполните сценарий с помощью python2. В другом случае выполните команду «как есть». ([Подробнее](https://github.com/getsolus/ypkg/pull/1))
**%python_compile** | Компилирует файлы `* .py` с использованием python2. Это полезно только тогда, когда сборка их еще не компилирует (на это указывает наличие файлов `* .pyc`).
**%python3_setup** | Запускает часть сборки setup.py с использованием python3.
**%python3_install** | Запускает установочную часть setup.py в соответствующий корень с помощью python3.
**%python3_test** | Без аргументов запускает тестовую часть setup.py. Используя сценарий `.py`, выполните сценарий с помощью python3. В другом случае выполните команду «как есть». ([Подробнее](https://github.com/getsolus/ypkg/pull/1))
**%python3_compile** | Компилирует файлы `*.py` с использованием python3. Это полезно только тогда, когда сборка их еще не компилирует (на это указывает наличие файлов `*.pyc`).

### Действующие макросы Ruby

Макросы | Описание
---- | ----
**%gem_build** | Запускает сборку gem.
**%gem_install** | Запускает установку gem с соответствующими параметрами.

### Действующие макросы Qt

Макросы | Описание
---- | ----
**%qmake** | Запускает qmake для Qt5 с соответствующими флагами make.
**%qmake4** | Запускает qmake для Qt4, а также добавляет необходимые флаги MOC, RCC и UIC, поскольку эти исполняемые файлы Qt4 заканчиваются на -qt4.
**%qml_cache** | Компилирует файлы `*.qml` в `*.qmlc`, чтобы они компилировались заранее.

### Действующие макросы Waf

Макросы | Описание
---- | ----
**%waf_configure** | Запускает настройку waf с префиксом.
**%waf_build** | Запускает waf и передает нашу переменную %JOBS%.
**%waf_install** | Запускает установку waf и передает соответствующие переменные `destdir` и`%JOBS%`

### Variable Macros

Макросы | Описание
---- | ----
**%ARCH%** | Указывает текущую архитектуру сборки.
**%CC%** | Cи-компилятор
**%CFLAGS%** | cflags, как установлено в `eopkg.conf`
**%CONFOPTS%** | Флаги/параметры для конфигурации, такие как `--prefix =% PREFIX%`. [Полный список.](Https://github.com/getsolus/ypkg/blob/master/ypkg2/rc.yml#L327-L329)
**%CXX%** | C++-компилятор
**%CXXFLAGS%** | cxxflags, как установлено в `eopkg.conf`
**%JOBS%** | jobs, как установлено в `eopkg.conf`
**%LDFLAGS%** | ldflags, как установлено в `eopkg.conf`
**%LIBSUFFIX%** | Суффикс библиотеки (32 для 32-разрядной версии или 64 для 64-разрядной версии)
**%PREFIX%** | Жестко запрограммированный префикс `/ usr`
**%YJOBS%** | Количество заданий без `-j`, как установлено в` eopkg.conf`
**%installroot%** | Жестко запрограммированный каталог установки
**%libdir%** | Каталог библиотеки по умолчанию для дистрибутива, то есть `/ usr / lib64` (изменяет для` emul32`)
**%version%** | Версия пакета, указанная в ключе версии.
**%workdir%** | Жестко запрограммированный рабочий каталог (дерево исходных текстов)

## Переменные

Набор переменных экспортируется на наших этапах сборки. Они используются для обеспечения контекста и структуры сценариев

Переменные | Описание
---- | ----
**$CFLAGS** | cflags as set in `eopkg.conf`
**$CXXFLAGS** | cxxflags as set in `eopkg.conf`
**$LDFLAGS** | ldflags as set in `eopkg.conf`
**$CC** | C compiler
**$CXX** | C++ compiler
**$EMUL32BUILD** | Set only when compiling in `emul32` mode
**$installdir** | The install directory, i.e. where files are installed to for packaging
**$pkgfiles** | Refers to the `./files` directory relative to the `package.yml` file
**$sources** | Refers to the directory where your source files are stored e.g. `$sources/nano.tar.gz`
**$workdir** | The work, or source, directory of the package build

## Типы

Файл `package.yml` использует собственные типы YAML, однако он следует синтаксическим соглашениям и может принимать несколько типов значений для данного ключа.

### string
Это просто текст, который не нужно объяснять.

### string(s)

Указывает, что можно использовать `список` строк или одну единственную `строку`.

### integer

Целое положительное число, используемое в поле «release».

### list

Список (или массив) YAML может быть выражен несколькими способами. Краткая запись массива будет выглядеть так:

`[1, 2, 3]`

Также их можно выразить так:

``` yaml
- Первое значение
- Второе значение
- Третье значение
```

### dict

Известный как ассоциативный массив, это ключ к отображению значений. Они разделены двоеточием (`:`), токен слева считается ключом, а токен справа - значением.

`Ключ: корреспондирующее ему значение`

Обратите внимание, что каждый `ключ ypkg` в файле YAML на самом деле является dict.

### dict(s)

dict (s) состоит из списка dict и некоторых предположений. Мы в первую очередь используем это, чтобы выразить расширенную информацию внутри пакета. Они позволяют вам указывать не ключ, а только значение.
В этом случае неявно предполагается, что ключ является именем пакета (например, `nano`):

`- некоторое значение`

Явный ключ, обычно имя подпакета:

`- некотороеимя: некоторое значение`

Смесь обоих:

``` yaml
- некоторое значение
- некотороеимя: другое значение`
```

Значения также могут быть выражены в виде списка с использованием той же логики ключей по умолчанию:

``` yaml
- [один, два, три]
- некоторый ключ: [один, два, три]
- другие ключи:
    - значение один
    - значение два
    - значение три
```

## Packaging Practices

Концепции в этом документе просто раскрывают синтаксис файла `package.yml`. Solus придерживается строгих правил и правил упаковки, которым должны следовать упаковщики. Они описаны в статье "Практика упаковки".

Original from https://getsol.us/articles/packaging/package.yml/en/ Translated into Russian Dr.Sheppard | GBOG@protonmail.com 
